"""
Avoid complications of spherical geometry
by working in 3-d Cartesian space.
"""

from math import sqrt

import numpy as np

from opt_nn.improved import h_distance


def euclidean(p1, p2, square_root=False):
    """
    Return (square of) Euclidean distance between 3-d points.
    """

    if p1 is None or p2 is None:
        return np.inf

    dx = p1.x - p2.x
    dy = p1.y - p2.y
    dz = p1.z - p2.z

    sum_of_squares = dx ** 2 + dy ** 2 + dz ** 2

    if square_root:
        return sqrt(sum_of_squares)
    else:
        return sum_of_squares


def closest_points(pivot, points, k, metric=euclidean):
    """
    Return k closest points to pivot.
    """

    return sorted(points, key=lambda x: euclidean(pivot, x))[:k]


def make_point_list(dataframe):
    '''
    Transform dataframe generated by `given.make_data()`
    to list of Points.
    '''

    df = transform_coords(dataframe)
    return list(df.apply(lambda x: CartesianPoint(x), axis=1))


class CartesianPoint():
    '''
    Point in Cartesian 3-D space.
    '''

    def __init__(self, row=None):
        '''
        Create point from pandas row.
        '''

        self.name = row.name
        self.x = row.x
        self.y = row.y
        self.z = row.z
        self.sq_distances = dict()
        

    def __repr__(self):
        '''
        Readable representation of point.
        '''

        return (f'{self.name}: '
                f'(x:{self.x:.2f}, '
                f'y:{self.y:.2f}, '
                f'z:{self.z:.2f})')


    def equals(self, point):
        '''
        Return true if points have identical labels
        or locations.
        '''

        if self.name == other_point.name:
            return True
        elif self.x == point.x \
                and self.y == point.y \
                and self.z == point.z:
            return True
        else:
            return False


    def dist(self, point):
        '''
        Return squared distance to other point.
        '''

        if not point in self.sq_distances.keys():
            self.sq_distances[point] = euclidean(self, point)

        return self.sq_distances[point]


class KDTree:
    """
    Recursive spatial index built 
    by cycling through dimensional axes
    and splitting on median point.
    """

    axes = ("x", "y", "z")

    def __init__(self, points_list, depth=0):
        """Create new (branch of) tree with list of points."""

        n = len(points_list)
        self.depth = depth
        self.axis = self.axes[depth % len(self.axes)]

        if n > 0:
            sorted_points = sorted(points_list, 
                    key=lambda x: getattr(x, self.axis))

            self.node = sorted_points[n // 2]
            self.left = KDTree(sorted_points[: n // 2], 
                    self.depth + 1)
            self.right = KDTree(sorted_points[n // 2 + 1 :], 
                    self.depth + 1)
        else:
            self.node = None

    def __repr__(self):
        '''
        Represent KDTree by recursively showing nodes of it and its
        branches.
        '''

        return str(self.recursive_repr()).replace('_','')\
                .replace(", ''", '')


    def recursive_repr(self):
         if self.node is None:
             return '_'
         else:
             return (f'P{self.node.name}',
                     f'bLd{self.depth}', self.left.recursive_repr(),
                     f'bRd{self.depth}', self.right.recursive_repr())

    def knn(self, point, k=2, nearest=None):
        '''
        Return k nearest neighbours for given point, 
        including identical point.
        '''

        if nearest is None:
            nearest = []

        if self.node not None:

            # check what side of boundary we are on
            if getattr(point, self.axis) < getattr(
                    self.node, self.axis):
                next_branch, opposite = self.left, self.right
            else:
                next_branch, opposite = self.right, self.left

            # are current node or next branch in nearest
            nearest = nearest + [self.node]
            nearest = sorted(nearest,
                    lambda x: x.d(point))[:k]
            nearest = self.knn(point, k, nearest)

            # if furthest of nearest is further than boundary
            # need to also check opposite branch
            if point.d(nearest[-1]) 








def transform_coords(df):
    '''Transform lat/lng to cartesian'''

    df[["theta", "phi"]] = np.radians(df[["lng", "lat"]])
    df["x"] = np.cos(df.theta) * np.cos(df.phi)
    df["y"] = np.sin(df.theta) * np.cos(df.phi)
    df["z"] = np.sin(df.phi)

    return df


def use_3dtree(df):
    """Use 3-dimensional k-d tree to give solution"""

    
    df["point_index"] = df.index

    # first transform to 3-d cartesian coordinates
    df = transform_coords(df)

    # then construct kd-tree
    tree = KDTree(df)

    # then use to find nearest neighbours
    df.neighbour_index = df.apply(
            lambda x: tree.find_nn(x).point_index, axis=1)

    df["euclidean_square"] = df.apply(
        lambda x: euclidean(x, df.iloc[x.neighbour_index]), axis=1
    )

    # then find spherical distance using haversine formula
    df.distance_km = df.apply(
        lambda x: h_distance(x, df.iloc[x.neighbour_index]), axis=1
    )

    return df

