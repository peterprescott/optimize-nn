"""
Attempt to solve nearest-neighbours on surface of sphere
by transforming points from spherical longitude/latitude
to Cartesian x-y-z, as Euclidean metric in 3-D will give 
same nearest-neighbours as Haversine metric on the sphere.

TODO: Fix the KDTree.knn() algorithm, which for some reason
is unsuccessful a small percentage of the time (failure
seems to increase as n increases.)
"""

from math import sqrt

import pandas as pd
import numpy as np

from opt_nn.improved import h_distance


def euclidean(p1, p2, square_root=False):
    """
    Return (square of) Euclidean distance between 3-d points.
    """

    if p1 is None or p2 is None:
        return np.inf

    dx = p1.x - p2.x
    dy = p1.y - p2.y
    dz = p1.z - p2.z

    sum_of_squares = dx**2 + dy**2 + dz**2

    if square_root:
        return sqrt(sum_of_squares)
    else:
        return sum_of_squares


def make_point_list(dataframe):
    '''
    Transform dataframe generated by `given.make_data()`
    to list of Points.
    '''

    df = dataframe.copy()
    df = transform_coords(df)
    return list(df.apply(lambda x: CartesianPoint(x), axis=1))


class CartesianPoint():
    '''
    Point in Cartesian 3-D space.
    '''
    def __init__(self, row=None):
        '''
        Create point from pandas row.
        '''

        self.name = row.name
        self.x = row.x
        self.y = row.y
        self.z = row.z
        self.sq_distances = dict()

    def __repr__(self):
        '''
        Readable representation of point.
        '''

        return (f'{self.name}: '
                f'(x:{self.x:.2f}, '
                f'y:{self.y:.2f}, '
                f'z:{self.z:.2f})')

    def dist(self, point):
        '''
        Return squared distance to other point.
        '''

        if not point in self.sq_distances.keys():
            self.sq_distances[point] = euclidean(self, point)

        return self.sq_distances[point]


class KDTree:
    """
    Recursive spatial index built 
    by cycling through dimensional axes
    and splitting on median point.
    """

    axes = ("x", "y", "z")

    def __init__(self, points_list, depth=0):
        """Create new (branch of) tree with list of points."""

        # meant to take list of points, not dataframe,
        # but since given.slow() takes a df this might be helpful.
        if isinstance(points_list, pd.DataFrame):
            points_list = make_point_list(points_list)

        n = len(points_list)
        self.depth = depth
        self.axis = self.axes[depth % len(self.axes)]

        if n > 0:
            sorted_points = sorted(points_list,
                                   key=lambda x: getattr(x, self.axis))

            self.node = sorted_points[n // 2]
            self.left = KDTree(sorted_points[:n // 2], self.depth + 1)
            self.right = KDTree(sorted_points[n // 2 + 1:], self.depth + 1)
        else:
            self.node = None

    def __repr__(self):
        '''
        Represent KDTree by recursively showing nodes of it and its
        branches.
        '''

        return str(self.recursive_repr()).replace('_','')\
                .replace(", ''", '')

    def recursive_repr(self):
        '''
        Generate recursive string.
        '''
        if self.node is None:
            return '_'
        else:
            return (f'P{self.node.name}', f'bLd{self.depth}',
                    self.left.recursive_repr(), f'bRd{self.depth}',
                    self.right.recursive_repr())

    def knn(self, point, k=2, nearest=None):
        '''
        Return k nearest neighbours for given point, 
        including identical point.
        '''

        # start by making a list to store nearest so far
        if nearest is None:
            nearest = [None] * k

        # if node is None we have reached end of the branch
        if self.node is None:
            return nearest
        else:

            # if current node is not yet in the nearest list
            # and is nearer than the furthest nearest neighbour
            # then replace it

            if self.node not in nearest and \
                    point.dist(self.node) < point.dist(nearest[-1]):
                nearest = nearest[:-1] + [self.node]
                nearest = sorted(nearest, key=lambda x: point.dist(x))[:k]

            # get next branch
            boundary_diff = \
                getattr(point, self.axis) - getattr(self.node, self.axis)
            if boundary_diff < 0:
                next_branch, opposite = self.left, self.right
            else:
                next_branch, opposite = self.right, self.left

            # find nearest neighbours on next_branch
            nearest = next_branch.knn(point, k, nearest)

            # if necessary, check on opposite branch
            if point.dist(nearest[-1]) >= abs(boundary_diff) ** 2:
                nearest = opposite.knn(point, k, nearest)

        return nearest


def transform_coords(df):
    '''Transform lat/lng to cartesian'''

    df = df.copy()
    df[["theta", "phi"]] = np.radians(df[["lng", "lat"]])
    df["x"] = np.cos(df.theta) * np.cos(df.phi)
    df["y"] = np.sin(df.theta) * np.cos(df.phi)
    df["z"] = np.sin(df.phi)

    return df


def use_3dtree(df):
    """Use 3-dimensional k-d tree to give solution"""

    df = transform_coords(df)

    # make point list from dataframe
    points = make_point_list(df)

    # then construct kd-tree
    tree = KDTree(points)

    # then use to find nearest neighbours
    df.neighbour_index = df.apply(
        lambda x: tree.knn(CartesianPoint(x))[1].name, axis=1)

    # then find spherical distance using haversine formula
    df.distance_km = df.apply(
        lambda x: h_distance(x, df.iloc[x.neighbour_index]), axis=1)

    return df
