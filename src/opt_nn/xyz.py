"""
Avoid complications of spherical geometry
by working in 3-d Cartesian space.
"""

from math import sqrt

import numpy as np

from opt_nn.improved import h_distance


def euclidean(p1, p2, square_root=False):
    """
    Return (square of) Euclidean distance between 3-d points.
    """

    if p1 is None or p2 is None:
        return np.inf

    dx = p1.x - p2.x
    dy = p1.y - p2.y
    dz = p1.z - p2.z

    sum_of_squares = dx ** 2 + dy ** 2 + dz ** 2

    if square_root:
        return sqrt(sum_of_squares)
    else:
        return sum_of_squares


def closest_points(pivot, points, k, metric=euclidean):
    """
    Return k closest points to pivot.
    """

    return sorted(points, key=lambda x: euclidean(pivot, x))[:k]


def make_point_list(dataframe):
    '''
    Transform dataframe generated by `given.make_data()`
    to list of Points.
    '''

    df = transform_coords(dataframe)
    return list(df.apply(lambda x: CartesianPoint(x), axis=1))


class CartesianPoint():
    '''
    Point in Cartesian 3-D space.
    '''

    def __init__(self, row=None):
        '''
        Create point from pandas row.
        '''

        self.name = row.name
        self.x = row.x
        self.y = row.y
        self.z = row.z
        
    def __repr__(self):
        '''
        Readable representation of point.
        '''

        return (f'{self.name}: '
                f'(x:{self.x:.2f}, '
                f'y:{self.y:.2f}, '
                f'z:{self.z:.2f})')


    def equals(self, point):
        '''
        Return true if points have identical labels
        or locations.
        '''

        if self.name == other_point.name:
            return True
        elif self.x == point.x \
                and self.y == point.y \
                and self.z == point.z:
            return True
        else:
            return False


    def sq_distance(self, point):
        '''
        Return squared Euclidean distance.
        '''

        return euclidean(self, point, square_root=False)


class KDTree:
    """
    Recursive spatial index built 
    by cycling through dimensional axes
    and splitting on median point.
    """

    axes = ("x", "y", "z")

    def __init__(self, points_list, depth=0):
        """Create new (branch of) tree with list of points."""

        n = len(points_list)
        self.depth = depth
        self.axis = self.axes[depth % len(self.axes)]

        if n > 0:
            sorted_points = sorted(points_list, 
                    key=lambda x: getattr(x, self.axis))

            self.node = sorted_points[n // 2]
            self.left = KDTree(sorted_points[: n // 2], 
                    self.depth + 1)
            self.right = KDTree(sorted_points[n // 2 + 1 :], 
                    self.depth + 1)
        else:
            self.node = None

    def __repr__(self):
        '''
        Represent KDTree by recursively showing nodes of it and its
        branches.
        '''

        return str(self.recursive_repr()).replace('_','')\
                .replace(", ''", '')

    def recursive_repr(self):
         if self.node is None:
             return '_'
         else:
             return (self.node.name,
                     f'L{self.depth}', self.left.recursive_repr(),
                     f'R{self.depth}', self.right.recursive_repr())

    def find_knn(self, points, k):
        """
        Find k nearest neighbours on this (branch of) tree for given
        points.
        """

        if self.node is None:
            return None

        for point in points:


            # first check what side of the boundary we are on
            if point[self.axis] < self.node[self.axis]:
                next_branch, opposite = self.left, self.right
            else:
                next_branch, opposite = self.right, self.left

            # check if point is closer to the current node
            # or a point on the next branch
            closest = closer_distance(point, self.node, next_branch.find_nn(point))

            # if we are closer to the boundary than the current closest
            # then we also need to check our current closest
            # is better than the nearest neighbour on the opposite branch
            if (
                euclidean(point, closest)
                > (
                    # square of distance to axis boundary
                    point[self.axis]
                    - self.node[self.axis]
                )
                ** 2
            ):
                closest = closer_distance(point, closest, opposite.find_nn(point))

            # also need to make sure we don't bounce on same point
            if same_point(point, self.left.node):
                closest = closer_distance(point, closest,
                        self.left.find_nn(point))
            elif same_point(point, self.right.node):
                closest = closer_distance(point, closest,
                        self.right.find_nn(point))

            return closest





def transform_coords(df):
    '''Transform lat/lng to cartesian'''

    df[["theta", "phi"]] = np.radians(df[["lng", "lat"]])
    df["x"] = np.cos(df.theta) * np.cos(df.phi)
    df["y"] = np.sin(df.theta) * np.cos(df.phi)
    df["z"] = np.sin(df.phi)

    return df


def use_3dtree(df):
    """Use 3-dimensional k-d tree to give solution"""

    
    df["point_index"] = df.index

    # first transform to 3-d cartesian coordinates
    df = transform_coords(df)

    # then construct kd-tree
    tree = KDTree(df)

    # then use to find nearest neighbours
    df.neighbour_index = df.apply(
            lambda x: tree.find_nn(x).point_index, axis=1)

    df["euclidean_square"] = df.apply(
        lambda x: euclidean(x, df.iloc[x.neighbour_index]), axis=1
    )

    # then find spherical distance using haversine formula
    df.distance_km = df.apply(
        lambda x: h_distance(x, df.iloc[x.neighbour_index]), axis=1
    )

    return df

